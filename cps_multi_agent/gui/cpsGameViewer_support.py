#! /usr/bin/env python
#
# Support module generated by PAGE version 4.3.2
# In conjunction with Tcl version 8.6
#    Nov 19, 2014 12:43:36 PM


import sys, os
projectDir = os.path.dirname(os.path.dirname(__file__))
sys.path.append(os.path.join(projectDir, "fsa"))
sys.path.append(os.path.join(projectDir, "src"))

from cpsFsmIndividual import fsmIndiv
from cpsFsmTurnProduct import fsmTurnProduct
import numpy as np
from cpsFsmLabelFunctions import *
import colorsys
import cPickle as pickle
import tkFileDialog

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global spinbox
    spinbox = StringVar()
    return


def init(top, gui, arg=None):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    return

def destroy_window ():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
    return

class guiState(object):
    def __init__(self):
        '''Constructor'''
        self.currState = None
        self.currMove = None
        self.xSqSide = 0
        self.ySqSide = 0
        self.arenaDimensions = None
        self.canvasWidth = 0
        self.canvasHeight = 0
        self.robotDot = None
        self.envDot = None
        self.robotPos = None
        self.envPos = None
        self.gameStateLabels = None
        self.filename = None
        self.agentColor = None
        self.labelColor = None
        self.labelIndex = None
        self.stateLabels = None
        self.maxMove = None
        self.numLabels = None
        self.numRobots = None
        self.numEnv = None
        self.turmProduct = None
        self.bottomFlag = None
        self.topFlag = None
        return
    
    def selectFileCallback(self):
        projectDir = os.path.dirname(os.path.dirname(__file__))
        filename = tkFileDialog.askopenfilename(initialdir=os.path.join(projectDir,'game_runs') )
        if filename:
            self.gameLog = pickle.load( open(filename, "rb") )
            
            self.stateLabels = self.gameLog['stateLabels']
            self.arenaDimensions = self.gameLog['arenaDimensions']
            self.actionLog = self.gameLog['actionLog']
            self.stateLog = self.gameLog['stateLog']
            self.agentColor = self.gameLog['agentColor']
            self.labelColor = self.gameLog['labelColor']
            self.labelIndex = self.gameLog['labelIndex']
            self.labelDisplayExcl = self.gameLog['labelDisplayExcl']
            self.numLabels = self.gameLog['numLabels']
            self.numRobots = self.gameLog['numRobots']
            self.numEnv = self.gameLog['numEnv']
            self.turnProduct = self.gameLog['turnProduct']
            self.grammarLog = self.gameLog['grammarLog']
            self.maxMove = len(self.stateLog)-1
            self.filename = filename
            
            
            w.btnNext.configure(state=NORMAL)
            w.btnPrev.configure(state=NORMAL)
            w.btnReset.configure(state=NORMAL)

            self.generateLegend()
            self.resetCallback()
        
        return
    
    def resetCallback(self):
        self.currMove = 0
        self.topFlag = False
        self.bottomFlag = False
        
        w.txtOutput.delete(1.0, END)
        w.txtOutput.insert(END,'Initial Grammar=%s\n' % str(self.grammarLog[0]))

        self.redrawAll()
        return
    
    def interpretStateID(self, stateID):
        '''Break state ID into meaningful components'''
        
        stateID = stateID.split('_')
        envPos = [[int(x) for x in i] for i in stateID[1:self.numEnv*2:2]]
        robotPos = [[int(x) for x in i] for i in stateID[self.numEnv*2+1:self.numEnv*2+1+self.numRobots*2:2]]
        
        return robotPos, envPos
        
    def prevCallback(self):
        global w
        self.currMove = max([0,self.currMove-1])

        if self.bottomFlag:
            w.txtOutput.insert(END,'Game recording ends\n')
            w.txtOutput.see(END)
            root.update_idletasks()
        else:
            self.redrawAll(buttonCode = 'prev')
            self.topFlag = False
            self.bottomFlag = False            
        
        if self.currMove == 0:
            self.bottomFlag = True
                    
        return
               
    def nextCallback(self):
        global w
        self.currMove = min([self.maxMove,self.currMove+1])

        if self.topFlag:
            w.txtOutput.insert(END,'Game recording ends\n')
            w.txtOutput.see(END)
            root.update_idletasks()
        else:
            self.redrawAll(buttonCode = 'next')
            self.topFlag = False
            self.bottomFlag = False            
        
        if self.currMove == self.maxMove:
            self.topFlag = True
        return
    
    def displayInfo(self):
        global w
        if self.currState and self.currMove != 0:
            w.txtOutput.insert(END,'Move agent %s=%s\n' %(self.stateLog[self.currMove-1][-2:], 
                                                          str(self.actionLog[self.currMove-1])))        
        
        if self.currState and (self.currMove-1)%(self.numRobots+self.numEnv) == 0:
            currAdvMove = int((self.currMove-1)/(self.numRobots+self.numEnv))+1
            w.txtOutput.insert(END,'Grammar=%s\n' % str(self.grammarLog[currAdvMove]))
            
            w.txtOutput.insert(END,'New Subsequences=%s\n' % str(set.difference(self.grammarLog[currAdvMove],
                                                                                self.grammarLog[currAdvMove-1])))
        w.txtOutput.see(END)
        return
        
    def redrawAll(self, buttonCode=None):
                    
        self.currState = self.stateLog[self.currMove]
        self.robotPos, self.envPos = self.interpretStateID(self.currState)
        
        if buttonCode == 'next':
            self.displayInfo()
                        
        self.drawGrid()
        self.redrawDots()
        self.redrawLabelDots()
        root.update_idletasks()
        return

    def drawGrid(self):
        '''Draw arena grid'''
        global w, root
        w.canvasBoard.delete(ALL)
        
        self.canvasWidth = float(root.winfo_width())*0.52
        self.canvasHeight = float(root.winfo_height())*0.91
        
        self.xSqSide = self.canvasWidth/self.arenaDimensions[0]
        self.ySqSide = self.canvasHeight/self.arenaDimensions[1] 
        
        
        lineXCoord = np.linspace(0, self.canvasWidth, self.arenaDimensions[0]+1)
        lineYCoord = np.linspace(0, self.canvasHeight, self.arenaDimensions[1]+1)
                        
        for i in lineXCoord:
            w.canvasBoard.create_line(i,0,i,self.canvasHeight)

        for i in lineYCoord:
            w.canvasBoard.create_line(0,i,self.canvasWidth,i)
        return

    def remapCoord(self,x,y):
        remapX = x
        remapY = self.arenaDimensions[1]-1-y
        return remapX, remapY
        
    def getAgentBoundingBox(self,x,y):      
        bbX1 = (x+0.1)*self.xSqSide
        bbY1 = (y+0.25)*self.ySqSide
        bbX2 = bbX1+0.5*self.xSqSide
        bbY2 = bbY1+0.5*self.ySqSide
        return [bbX1,bbY1,bbX2,bbY2]

    def getLabelBoundingBox(self,x,y,labelI):  
        labelInc = np.minimum(0.2,(0.9/self.numLabels))    
        bbX1 = (x+0.7)*self.xSqSide
        bbY1 = (y+0.05+labelInc*labelI)*self.ySqSide
        bbX2 = bbX1+labelInc*self.xSqSide
        bbY2 = bbY1+labelInc*self.ySqSide
        return [bbX1,bbY1,bbX2,bbY2]
    
    def redrawDots(self):
        global w
        
        w.canvasBoard.delete(ALL)
        self.drawGrid()
        
        agentColor = deepcopy(self.agentColor)
        agentPos = self.envPos[:] + deepcopy(self.robotPos)
        
        while len(agentPos) != 0:
            if agentPos[0] != None:
                ind = [i for i, x in enumerate(agentPos) if x == agentPos[0]]
                agX, agY = self.remapCoord(agentPos[0][0], agentPos[0][1])
                agBB = self.getAgentBoundingBox(agX, agY)
                
                for i in xrange(len(ind)):
                    if len(ind) == 1:
                        w.canvasBoard.create_oval(agBB, fill=agentColor[i])
                    else:                        
                        w.canvasBoard.create_arc(agBB, start=(360/len(ind))*i, extent=360/len(ind), fill=agentColor[ind[i]]) 
                    
                agentColor = [i for j, i in enumerate(agentColor) if j not in ind]
                agentPos = [i for j, i in enumerate(agentPos) if j not in ind]
                
            else:
                del agentPos[0]
                del agentColor[0]
                           
        return
    
    def redrawLabelDots(self):
        for prop in self.stateLabels[self.currState].keys():
            if prop not in self.labelDisplayExcl:
                propIndex = self.labelIndex[prop]
                propColor = self.labelColor[propIndex]
                
                for lpos in self.stateLabels[self.currState][prop]:
                    pos = np.unravel_index(lpos,self.arenaDimensions)
                    x, y = self.remapCoord(pos[0], pos[1])
                    BB = self.getLabelBoundingBox(x, y, propIndex)
                    w.canvasBoard.create_oval(BB,fill=propColor)
        return
                    
    def generateLegend(self):
        global w

        startX = 20
        startY = 30
        circDia = 20
        lineGap = 20
        
        for i in xrange(self.turnProduct.numAgents):
            x = startX
            y = startY+i*(circDia+lineGap)  
            w.canvasLegend.create_oval([x,y,x+circDia,y+circDia],fill=self.agentColor[i])
            w.canvasLegend.create_text([x+circDia+5,y-2], anchor=NW, text=self.turnProduct.agentNames[i])
                
        startX = 100
        startY = 30
        circDia = 10
        lineGap = 10
        
        for i in self.labelIndex.keys():
            x = startX
            y = startY+self.labelIndex[i]*(circDia+lineGap)  
            w.canvasLegend.create_oval([x,y,x+circDia,y+circDia],fill=self.labelColor[self.labelIndex[i]])
            w.canvasLegend.create_text([x+circDia+5,y-2], anchor=NW, text=i)
        return

    def windowResizeCallback(self, event):
        print "Window dimensions : ", event.width, event.height
        if self.filename != None:
            self.redrawAll()
        return        
        
if __name__=="__main__":
    myGuiState = guiState()
    pass
    
