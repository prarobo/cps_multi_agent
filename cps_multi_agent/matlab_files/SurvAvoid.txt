/* Normlzd: (false V (((true U (p1)) && (true U (p2))) && ! ((p3)))) */

Alternating automaton before simplification
init :
{10}
state 10 : (false V (((true U (p1)) && (true U (p2))) && ! ((p3))))
p1 & p2 & {} -> {10}
p1 & {} -> {5,10}
p2 & {} -> {3,10}
{} -> {3,5,10}
state 9 : false
state 8 : (((true U (p1)) && (true U (p2))) && ! ((p3)))
{} -> {3,5}
p2 & {} -> {3}
p1 & {} -> {5}
p1 & p2 & {} -> {}
state 7 : ! ((p3))
{} -> {}
state 6 : ((true U (p1)) && (true U (p2)))
p1 & p2{} -> {}
p1{} -> {5}
p2{} -> {3}
1{} -> {3,5}
state 5 : (true U (p2))
1{} -> {5}
p2{} -> {}
state 4 : (p2)
p2{} -> {}
state 3 : (true U (p1))
1{} -> {3}
p1{} -> {}
state 2 : true
1{} -> {}
state 1 : (p1)
p1{} -> {}

Alternating automaton after simplification
init :
{10}
state 10 : (false V (((true U (p1)) && (true U (p2))) && ! ((p3))))
p1 & p2 & {} -> {10}
p1 & {} -> {5,10}
p2 & {} -> {3,10}
{} -> {3,5,10}
state 5 : (true U (p2))
1{} -> {5}
p2{} -> {}
state 3 : (true U (p1))
1{} -> {3}
p1{} -> {}

Generalized Buchi automaton before simplification
init :
1
state 1 ({10}) : 2
p3 -> 1 : {}
p2 & p3 -> 1 : {5}
p1 & p3 -> 1 : {3}
p1 & p2 & p3 -> 1 : {3,5}

Generalized Buchi automaton after simplification
init :
1
state 1 ({10}) : 1
p3 -> 1 : {}
p2 & p3 -> 1 : {5}
p1 & p3 -> 1 : {3}
p1 & p2 & p3 -> 1 : {3,5}

Buchi automaton before simplification
state init
p1 & p2 & {2} -> accept_1
p1 & {2} -> T1_1
{2} -> init
state accept_1
p1 & p2 & {2} -> accept_1
p1 & {2} -> T1_1
{2} -> init
state T1_1
p2 & {2} -> accept_1
{2} -> T1_1

Buchi automaton after simplification
state init
p1 & p2 & {2} -> accept_1
p1 & {2} -> T1_1
{2} -> init
state accept_1
p1 & p2 & {2} -> accept_1
p1 & {2} -> T1_1
{2} -> init
state T1_1
p2 & {2} -> accept_1
{2} -> T1_1

never { /* [] <> p1 && [] <> p2 && [] ! p3 */
T0_init:
        if
        :: (p1 && p2 && !p3) -> goto accept_S1
        :: (p1 && !p3) -> goto T1_S1
        :: (!p3) -> goto T0_init
        fi;
accept_S1:
        if
        :: (p1 && p2 && !p3) -> goto accept_S1
        :: (p1 && !p3) -> goto T1_S1
        :: (!p3) -> goto T0_init
        fi;
T1_S1:
        if
        :: (p2 && !p3) -> goto accept_S1
        :: (!p3) -> goto T1_S1
        fi;
}
